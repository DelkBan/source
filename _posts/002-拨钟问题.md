---
title: '002:拨钟问题'
date: 2018-09-12 15:25:17
tags:
- c++
- 算法
- 枚举
---

###  问题还原

##### 002: 拨钟问题

总时间限制: 1000ms 内存限制: 65536kB

##### 描述

有9个时钟，排成一个3*3的矩阵。

<!--more-->

        |-------|    |-------|    |-------|
        |       |    |       |    |   |   |
        |---O   |    |---O   |    |   O   |
        |       |    |       |    |       |
        |-------|    |-------|    |-------|
        A            B            C    
    
        |-------|    |-------|    |-------|
        |       |    |       |    |       |
        |   O   |    |   O   |    |   O   |
        |   |   |    |   |   |    |   |   |
        |-------|    |-------|    |-------|
        D            E            F    
    
        |-------|    |-------|    |-------|
        |       |    |       |    |       |
        |   O   |    |   O---|    |   O   |
        |   |   |    |       |    |   |   |
        |-------|    |-------|    |-------|
        G            H            I    
        				(图 1)



现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。


    移动    影响的时钟
    
     1         ABDE
     2         ABC
     3         BCEF
     4         ADG
     5         BDEFH
     6         CFI
     7         DEGH
     8         GHI
     9         EFHI   


##### 输入

9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。

##### 输出

输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。

##### 样例输入

    3 3 0 
    2 2 2 
    2 1 2 

##### 样例输出

	4 5 8 9 

### 解题分析

由于问题的规模是固定的，故可以使用暴力穷举的方式进行解题，最多有4<sup>9</sup>个组合，我也是使用的这种方法进行的解题，大的面上很简单，有一个小细节在这里说一下。
最后输出的时候，因为每种操作不一定只进行了一次，因此采用下列语句输出：

```
for (cur = 0; cur < 9; cur++)
  while (move_count[cur]--)
   cout<<cur + 1<<" ";
```

另外还有一一种做法就是类似于之前的熄灯问题和密码锁问题，找到一个局部，然后顺次分析。

对方法1,2,3进行枚举，每种方法实施0--3次，共4<sup>3</sup>种情况。如果我们确定了1,2,3的情况属，则将得到灯A,B,C的状态，而只有移动4能够改变A，移动5能够改变B，移动6能够改变C，那么移动4--6的次数也确定了。同样的，这时只有移动7能够改变D，移动9能够改变F，这时移动7和9的次数也确定了。最后，时钟ABCDF都已经符合要求，EGHI还没有确定，剩下的只有移动8能够改变GHI，所以只要检查E是否已经达到要求并且GHI的时钟数是否相等即可。最后找到最小移动次数即可。

### 代码实现

我只使用暴力枚举进行了实现，代码如下：

```
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
 int oriState[9] = {0};
 for (int i = 0; i < 9; i++)
  cin>>oriState[i];
 int move_count[9] = {0};
 int min_count = 99;
 for (int i1 = 0; i1 < 4; i1++)
  for (int i2 = 0; i2 < 4; i2++)
   for (int i3 = 0; i3 < 4; i3++)
    for (int i4 = 0; i4 < 4; i4++)
     for (int i5 = 0; i5 < 4; i5++)
      for (int i6 = 0; i6 < 4; i6++)
       for (int i7 = 0; i7 < 4; i7++)
        for (int i8 = 0; i8 < 4; i8++)
         for (int i9 = 0; i9 < 4; i9++)
         {
          if ((0 == (i1 + i2 + i4 + oriState[0]) % 4) && (0 == (i1 + i2 + i3 + i5 + oriState[1])
              % 4) && (0 == (i2 + i3 + i6 + oriState[2]) % 4) && (0 == (i1 + i4 + i5 + i7 +
              oriState[3]) % 4) && (0 == (i1 + i3 + i5 + i7 + i9 + oriState[4]) % 4) && (0 ==
              (i3 + i5 + i6 + i9 + oriState[5])% 4) && (0 == (i4 + i7 + i8 + oriState[6]) % 4)
          && (0 == (i5 + i7 + i8 + i9 + oriState[7])% 4) && (0 == (i6 + i8 + i9 + oriState[8]) % 4))
          {
           int sum = i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9;
           if (min_count > sum)
           {
            min_count = sum;
            move_count[0] = i1;
            move_count[1] = i2;
            move_count[2] = i3;
            move_count[3] = i4;
            move_count[4] = i5;
            move_count[5] = i6;
            move_count[6] = i7;
            move_count[7] = i8;
            move_count[8] = i9;
           }
          }
         }
 int cur = 0;
 for (cur = 0; cur < 9; cur++)
  while (move_count[cur]--)
   cout<<cur + 1<<" ";
 cout<<endl;
 return 0;
} 
```