---
title: 用递归将问题分解成规模更小的子问题
date: 2018-09-27 18:21:06
tags:
- C++
- 算法
- 递归
---

#####  Tips

此类问题主要是要找到递推公式，一定要考虑到所有的情况，代码一般都不复杂

<!--more-->

##### 一、爬楼梯问题

爬楼梯，每次可以走1级或者2级，输入楼梯的级数，求不同的走法数。

例如，楼梯一共有三级，可以每次都走一级，或者第一次一级，第二次二级，也可以第一次两级，第二次一级。一共三种方法。

**输入**

包含若干行，每行包含一个正整数N，代表楼梯级数，1<=N<=30，每一行输入对应一行。

**输出**

不同的走法数，每一行输入对应一行输出

**样例输入**

    5
    8
    10

**样例输出**

    8
    34
    89

**分析**

整个问题可以分为两类，即先走一级和先走两级这两种，得到递推公式如下：

`f(n) = f(n-1)+f(n-2)

为了确保递推能够正常停止，需要增加边界条件，即n<0时，返回0，n=0时，返回1

**代码如下**

```c++

#include<iostream>
using namespace std;
int N;
int stairs(int N)
{
    if(n < 0)
    	return 0;
    if( n == 0)
    	return 1;
    return stairs(n-1) + stairs(n-2);
}
int main()
{
    while(cin >> N){
        cout << stairs(N) << endl;
    }
    return 0;
}

```

##### 二、放苹果

把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共多少种不同的分法？5,1,1和1,5,1是同一种分法。

**输入**

第一行是测试数据的数目t(0 <=t <= 20)。以下每行均包含两个整数M和N，以空格而分开。1 <= M,N<=10.

**输出**

对输入的每组数据M和N，用一行输出相应的K。

**样例输入**

    1
    7 3

**样例输出**

    8

**分析**

设i个苹果放在k个盘子里面的放法总数是f(i,k)，则：

k > i时，f(i,k) = f(i,i)
k <= i时，总放法=有盘子为空的放法+没盘子为空的放法

`f(i,k) = f(i,k-1) + f(i-k,k)`

边界条件见具体代码

**代码**

```c++

#include<iostream>
using namespace std;
int f(int m,int n){
    if( n >m )
    	return f(m,m);
    if( m == 0)
    	return 1;
    if( n <= 0)
    	return 0;
    return f(m,n-1) + f(m-n,n);
}
int main(){
    int t,m,n;
    cin >> t;
    while( t--){
        cin >> m >> n;
        cout << f(m,n) << endl;
    }
    return 0;
}

```

##### 三、简单的整数划分问题

将正整数n 表示成一系列正整数之和，n=n1+n2+…+nk, 其中n1>=n2>=…>=nk>=1 ，k>=1 。
正整数n 的这种表示称为正整数n 的划分。正整数n 的不同的划分个数称为正整数n 的划分数。

**输入**

标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 < N <= 50)。

**输出**

对于每组测试数据，输出N的划分数。

**样例输入**

    5

**样例输出**

    7

**分析**

这个问题和第二个问题很类似，假设q(n,m)是正整数n的以n1不超过m的划分数。

* q(n,1) = 1, n >= 1    用全一填，只有一种方法
* q(n,m) = q(n,n), m>=n   
* q(n,n) = q(n,n-1) + 1  左值多了一种单个n 的分法
* q(n,m)= q(n-m,m)+q(n,m-1), n>m

第四个式子即为递推公式，和前面的问题是一样的，这里正整数n的最大加数n1不大于m的划分由n1=m的划分和n1<=m-1的划分组成。

**代码**

```c++

#include <iostream>
using namespace std;
int ways(int n,int i)
{
	if( n == 0)
		return 1;
	if( i == 0)
		return 0;
	if( i <= n)
		return ways(n-i,i) + ways(n,i-1);  //用i和不用i的情况。i可以重复使用
	else
		return ways(n,i-1);	
	
}
int main()
{
	int n;
	while(cin >> n) 
		cout << ways(n,n) << endl;
}

```

